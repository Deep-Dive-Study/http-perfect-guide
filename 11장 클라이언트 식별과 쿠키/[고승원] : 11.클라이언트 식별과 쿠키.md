# 11. 클라이언트 식별과 쿠키

# 1. 개별 접촉

HTTP는 state less한 특성 때문에 사용자를 식별할 수 없다.

개인화된 서비스는 어떻게 사용자를 식별할까?

- 개별 인사 : 개개인에 특화된 메시지나 페이지를 만든다.
- 사용자 맞춤 추천 : 고객의 흥미를 학습해 제품을 추천한다.
- 저장된 사용자 정보 : 복잡한 정보를 저장하여 재사용한다. (카드, 주소)
- 세션 추적 : 많은 웹사이트에서 사용자를 식별할 수 있게 상태를 남긴다. (장바구니)
    - HTTP헤더, IP주소, 사용자 로그인, URL에 식별자 포함, 쿠키 등

# 2. HTTP 헤더

다음은 사용자 정보를 식별할 때 가장 많이 사용하는 헤더들이다.

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/4b36e261-a272-46e0-bb72-1d3c2abc0a30/92b8f1ce-baf7-4e28-8730-2f71842bf945/Untitled.png)

- FROM : 사용자의 이메일 주소. 스팸 문자 때문에 잘 사용하지 않음
- User-Agent : 사용자의 브라우저, OS 등등. 유저 식별에 큰 도움 안된다.
- Refer : 사용자가 어떤 페이지에서 방문한지 알려준다.

위 방법들은 사용자를 식별하기에 너무 정보가 제한적이다.

# 3. 클라이언트 IP 주소

클라이언트 IP 주소는 잘 바뀌지 않고, TCP 커넥션이 있다면 알 수 있다.

단점

- 사용자가 아닌 사용자 네트워크 주소를 식별하기 때문에 한 컴퓨터에 여러 사용자가 사용하면 식별 불가
- ISP는 로그인할 때 마다 동적으로 IP를 할당한다.
- NAT를 사용하는 경우 실제 IP주소는 보여지지 않는다.

# 4. 사용자 로그인

IP보다 인증을 통해 사용자를 식별하는게 좋다. Authorization 헤더도 있다.

status 401을 통해 인증을 요구할 수 있다. 인증된 사용자는 Authorization 헤더에 정보가 담겨진다.

이 정보는 세션이 진행되는 내내 유지된다.

# 5. 뚱뚱한 URL

URL에 사용자를 식별하는 정보를 포함할 수 있다.

https://www.amazon.com/b/ref=OUT_BS_DSC_D_EN_US/?_encoding=UTF8&node=17900676011&pd_rd_w=4lfaK&content-id=amzn1.sym.18e45841-e775-4e74-b94d-1f4c16e3f31a&pf_rd_p=18e45841-e775-4e74-b94d-1f4c16e3f31a&pf_rd_r=7NJP0WC8JRTZDE627471&pd_rd_wg=HyySt&pd_rd_r=9f746591-ea87-4a5d-b4c1-59765482b281&ref_=pd_gw_unk

아마존 URL의 경우 URL에 여러 정보를 담는다.

단점

- 못생긴 url : 보기 싫다.
- 공유 불가 : 개인 정보를 담고 있음.
- 캐시 사용 불가 : URL이 달라져 기존 캐시가 물거품이 됨
- 서버 부하 : 각각의 해당하는 URL에 해당하는 HTML을 새로 그려야 한다.
- 세션 간 지속성 부재 : 사용자가 다른 URL로 들어오면 정보는 사라진다.

# 6. 쿠키

사용자 식별, 세션 유지에 가장 널리 사용하는 방식이다. 쿠키를 사용하면 앞서 언급한 단점들이 모두 없어진다.

쿠키는 캐시와 충돌 위험이 있어서 캐싱되지 않는다.

## 6.1 쿠키의 타입

- 세션 쿠키 : 사용자가 사이트를 탐색할 때 관련 설정을 저장하는 임시 쿠키다. 브라우저를 닫으면 삭제된다.
- 지속 쿠키 : 디스크에 저장되어 길게 유지된다.

## 6.2 쿠키 동작 방식

쿠키는 Set_Cookie(2) 헤더에 이름=값 형태로 리스트를 가지고 있다.

브라우저는 사용자의 모든 쿠키를 읽을 수 있다.

- 구글 크롬 - SQLite 파일에 쿠키 저장
- 인터넷 익스플로러 - 캐시 디렉터리에 각각 개별 파일로 저장

브라우저는 수백개 이상의 쿠키를 가지지만, 요청마다 모두 전송하지 않는다.

- 모두 전달하면 성능 저하
- 쿠키들은 서버에 특화된 이름을 가져서 보내도 의미가 없음
- 개인정보 문제 야기

### 6.3 **쿠키 속성들**

- Domain : 이는 어떤 사이트가 그 쿠키를 읽고 제어하는지 나타낸다.
- Path : 웹사이트 일부에만 쿠키를 적용하는 기능

### 6.7 Version 0

넷스케이프라고 불리며, Set-Cookie 응답 헤더와 Cookie 요청 헤더와 쿠키 조작하는데 필요한 필드들을 정의했다.

```sql
Set-Cookie : name=value [; expires=date] [; path=path] [; domain=domain] [; secure]
Cookie : name1=value1 ...
```

도메인에 해당하는 쿠키중 파기되지 않은 쿠키를 요청에 담아 보낸다.

### 6.8 Version 1

RFC 2965 쿠키이며, Version 0과 호환된다.

- 쿠키마다 목적을 설명하는 설명문이 있다.
- 파기 주기에 상관없이 부라우저가 닫히면 쿠키를 강제삭제할 수 있다.
- 쿠키의 생명주기는 초단위로 바뀌었다.
- URL의 포트 번호로도 제어 가능하다.
- 도메인, 포트, 경로 필터가 있으면 Cookie 헤더에 담겨 되돌려 보낸다.
- 호환되는 쿠키 버전 번호가 있다.
- 사용자 이름과 추가적인 키워드를 구별하기 위해 Cookie 헤더에 $접두어가 있다.

```sql
Set-Cookie2: ID="1234"; Domain="adf.com"; Version="1"; Path="/asdf"
```

- Cookie2 요청 헤더는 각기 다른 쿠키 버전을 지원하는 클라이언트와 서버간에 호환성을 협상하는 용도로 사용된다.
    - 클라이언트는 서버로부터 받은 헤더 기준으로 보내야 한다.
    - 서버는 클라이언트가 모두 지원하면 Set-Cookie는 무시하고 Set-Cookie2를 확인한다.

### 6.8 쿠키와 세션 추적

세션쿠키를 사용해 정보를 유지하는데, 사용되는 flow를 알아보자.

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/4b36e261-a272-46e0-bb72-1d3c2abc0a30/f6655c7d-afd0-4b69-a2b4-ce1dd1e44760/Untitled.png)

- a : 브라우저가 페이지 요청
- b : 서버는 클라이언트를 리다이렉트
- c : 리다이렉트 URL로 페이지 요청
- d : 응답에 두 개의 세션 쿠키를 기술하고, 다른 URL로 리다이렉트
- e : 두 개의 쿠키와 함께 리다이렉트 URL로 페이지 요청 (뚱뚱한URL)
- f : home.html로 리다이렉트 시키며 쿠키 두 개 더 첨부
- g : home.html 로드하며 총 네 개의 쿠키 전달
- h : 서버는 컨텐츠를 보냄

### 6.9 쿠키와 캐싱

쿠키 트랜잭션과 관련된 문서를 캐싱하는 것은 주의해야 한다.

정보가 노출되거나, 다른 사용자에게 할당될 수 있기 때문이다.

캐시 기본 원칙

- 캐시되지 말아야 할 문서가 있다면 표시하라. `Cache-Control: no-cache="Set-Cookie"`
- Set-Cookie 헤더 캐시는 유의하라.
    - 사용자 추적에 실패할 수 있음.
    - 서버의 값과 검사해 문제 개선 가능 `Cache-Control: must-revalidate, max-age=0`
- Cookie 헤더를 가지고 있는 요청을 주의하라.
    - 개인정보를 포함하고 있을 수 있음

### 6.10 쿠키, 보안, 개인정보

- 쿠키 비활성화 가능함
- DB에 정보를 저장하고, 쿠키의 값으로 조회하도록 해도 됨
- 지속 쿠키를 사용해서 사용자를 추적하는 것은 위험하다
