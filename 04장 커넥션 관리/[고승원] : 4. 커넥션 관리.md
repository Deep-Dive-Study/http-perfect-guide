# 4. 커넥션 관리

HTTP 커넥션이 어떻게 이루어지고 어떻게 사용되는지 이해하는 장이다.

- HTTP의 TCP 커넥션 활용
- TCP 커넥션의 지연 병목 막힘
- 병렬, keep-alive, 파이프라인 등
- 커넥션 관리 규칙

## 1. TCP 커넥션

전세계 모든 HTTP 통신은 TCP/IP를 통해 이루어진다. (3.0 이전이라 그런듯)

따라서 TCP 통신의 가장큰 특징인 통신간에 주고받은 메시지가 손실/손상 혹은 순서가 바뀌지 않는다.

### 순서

1. 브라우저가 호스트명을 추출한다.
2. 브라우저가 호스트에 대한 IP를 찾는다.
3. 브라우저가 포트 번호를 얻는다.
4. TCP 커넥션을 생성한다.
5. 브라우저가 서버로 요청을 보낸다.
6. 브라우저가 서버에서 온 HTTP 응답 메시지를 읽는다.
7. 커넥션을 종료한다.

![image](https://github.com/Deep-Dive-Study/http-perfect-guide/assets/85796588/387d1021-f8de-463a-82d6-2abc14bfea7e)

이 사진 하나면 이해가 매우 쉬워진다.

### 특징

- TCP는 순서와 신뢰를 보장한다.
- 세그먼트 단위로 나누어 IP 패킷을 통해 전송된다.
    - 구성 : 패킷 헤더 20바이트 / 세그먼트 헤더 20바이트 / 데이터 조각 0바이트 이상

### TCP 커넥션 유지하기

- 컴퓨터는 항상 TCP 커넥션을 여러개 가지고 유지하고 있다.
- TCP 식별 정보는 다음과 같다 <발신지 IP, 발신지 포트, 수신지 IP, 수신지 포트>
- 각 커넥션의 구성은 유일하지만, 구성요소 일부가 같을 수 있다.

### TCP 소켓 프로그래밍

소켓은 unix OS용으로 만들어졌지만, API 구현체 덕분에 대부분의 OS와 언어에서 사용 가능하다.

소켓은 TCP의 엔드포인트에 데이터 구조를 연결하여 데이터 스트림을 읽고 쓸 수 있다.

소켓 API는 핸드셰이크, 데이터 스트림, 패킷의 분할 및 조립등 세부사항을 외부로부터 숨긴다.

![image](https://github.com/Deep-Dive-Study/http-perfect-guide/assets/85796588/41659626-ed00-43b3-8a81-eb8ce71a0d76)

## 2. TCP의 성능에 대한 고려

HTTP는 TCP 바로 위에 있는 계층이기 때문에 HTTP 트랜잭션은 TCP의 영향을 많이 받는다.

### 트랜잭션 지연

HTTP 트랜잭션 시간은 TCP 커넥션 초기화 하고, 요청, 응답, TCP 해제 시간을 모두 포함하는데 이중 실제 처리 시간은 길지 않다.

지연 원인은 다양하다.

- 도메인은 IP로 변환하는 과정 (DNS lookup)
- TCP 커넥션 생성 (몰릴시 느려짐)
- 요청, 응답 전송 레이턴시

다음과 같이 지연에는 여러가지 방법이 있지만 가장 일반적인 TCP 지연에 대해 알아보자.

핸드셰이크 같이 작은 데이터 전송을 위해 커넥션을 사용하면 자원이 낭비된다.

낭비되는 자원에 의해 생기는 지연을 제거하기위해 어떻게 커넥션을 이어갈까?

### 핸드셰이크 지연

- 인터넷은 라우터에 과부하가 걸리면 패킷을 파기한다. 따라서 TCP는 결과를 보장하기 위해 순번과 데이터 무결성 체크섬을 갖는다.
- 체크섬에 대한 응답은 크기가 작기 때문에 0.1~0.2초 정도 버퍼에 넣어뒀다가 편승(함께 전송)시킨다.

### TCP 느린 시작

- TCP 커넥션은 자동으로 튜닝되어 성공이 이어지면 속도 제한이 점점 풀린다. 이를 느린 시작이라 부른다.
- 한 번에 여러 커넥션에 응답하려면 부하가 생기기 때문이다. 비슷한 의미로 한 번에 전송 가능한 패킷 수를 제한한다. (점점 패킷 수가 늘어나는데, 이를 윈도 튜닝이라 한다)

### 네이글 알고리즘

- TCP의 세그먼트는 각각 40바이트 상당의 플래그와 헤더를 포함해 많은 수의 패킷을 보낸다면 무겁다.
- 따라서 TCP 패킷을 줄이기 위해 데이터를 한 개의 덩어리로 합친다. (크기는 확인응답보다 항상 작음)
- 네이글 알고리즘은 패킷을 채우지 못하거나, 확인 응답이 올때까지 지연된다.

### TIME_WAIT 지연과 포트 고갈

- TIME_WAIT 포트 고갈은 성능 측정시 심각한 성능 저하를 발생시키지만, 실제 상황에선 문제를 일으키지 않는다.
- TCP 커넥션을 종단에서 끊으면, 종단에선 커넥션의 IP 주소와 포트 번호를 메모리의 작은 제어영역에 기록해 놓는다.
- 기록에 있는 정보는 일정 시간동안 커넥션이 생성되지 않도록 한다. (보통 2분)

## 3. HTTP 커넥션 관리

### Connection 헤더

HTTP는 서버와 클라이언트 사이에 다른 서버가 놓이는걸 허락한다.

상황에 따라서 두 개의 인접한 HTTP 애플리케이션에 옵션을 지정해야 할때가 있다.

Connection 헤더 필드는 쉼표로 구분하며 다음 메시지를 보낸 다음 끊어져야 할 커넥션은 Connection: close라고 명시한다.

토큰 종류는 다음과 같다.

- HTTP 헤더 필드 명 : 이 커넥션에만 해당되는 헤더들을 나열한다.
- 임시적 토큰 값 : 커넥션에 대한 비표준 옵션
- close 값 : 커넥션 작업이 완료되면 종료되어야 함을 의미한다.

### 순차적인 트랜잭션 처리에 의한 지연

커넥션 관리는 TCP 성능과 매우 연관깊다. 순차적 트랜잭션은 상당한 지연을 안고있기에 여러가지 방법이 있다.

병렬 커넥션 : 여러개 요청 동시에 한다.

- 리소스를 효율적으로 활용하여 대체로 더 빠르지만, 리소스의 여유가 없는 경우는 차이가 없다.

지속 커넥션 : 커넥션을 초기화, 삭제하는 과정을 없에고, 재활용

- 사이트의 지역성에 의해 재사용할 수 있어 속도를 증가시킨다.
- 장점은 튜닝된 커넥션을 유지할 수 있는 것이고, 병렬에 비해 리소스를 크게 잡아먹지 않는다.
- 단점은 수많은 커넥션이 쌓여 리소스가 불필요하게 잡혀있을 수 있다. 병렬과 함께 사용하는게 가장 효과적이다.

파이프라인 커넥션 : 공유 TCP 커넥션을 통한 병렬 요청

다중 커넥션 : 요청과 응답들에 대한 중재

### Keep-Alive

HTTP/1.0

Keep-Alive는 지속 커넥션을 지원하기 위해 확장되었으며, 헤더에 Keep-Alive 헤더를 포함시킨다.

- max = 커넥션 개수 , timeout = 커넥션 시간
- 응답에도 Keep-Alive 헤더가 포함되어 와야하며, 엔티티의 본문 길이를 알아야 유지할 수 있다.

문제

- 프록시 서버에서 Connection 헤더를 삭제하지 않고, 서버까지 전달하기도 한다. 이를 Dumb 프록시라 한다.
- Proxy-Connection을 사용하면 해결된다.

![image](https://github.com/Deep-Dive-Study/http-perfect-guide/assets/85796588/5d5aefe6-7504-4a77-a429-a3aad035e80a)

HTTP/1.1

1.0과 다르게 Keep-Alive는 기본으로 확성화 되어있고, Connection: close 헤더로 연결을 끊는다.

규칙

- close 헤더를 보내면 추가 요청을 보낼 수 없다. (close로 연결을 끊는다)
- 자신의 길이정보가 없다면 커넥션을 지속시킬 수 없다.
- 프록시는 서버와 클라이언트 각각에 대해 별도의 지속 커넥션을 맺고 관리한다. (지원 범위를 꼭 알아야 한다)

## 6. 파이프라인 커넥션

지속 커넥션을 통해 요청을 파이프라이닝 할 수 있는데, 이는 Keep-Alive 성능을 더 높여준다.

원리

- 요청은 응답이 도착하기까지 큐에 쌓인다.
- 요청이 도착하면(지속 커넥션인지 확인해야함) 그동안 다른 요청을 전달할 수 있다.
- 응답은 요청 순서와 같게 와야한다.
- 클라이언트는 커넥션이 끊어지더라도 완료되지 않은 요청이 파이프라인에 있으면 언제든 다시 요청을 보낼 수 있어야 한다.
- 멱등성이 보장되지 않는 메서드는 파이프라이닝을 못쓴다. 문제가 발생할 수 있어서

## 7. 커넥션 끊기

서버 커넥션은 유휴상태에 빠지면 끊을 수 있다. 하지만 그 시점에, 클라이언트가 요청을 보내면 문제가 생긴다.

### Content-Length, Truncation

HTTP 응답 본문은 정확한 크기를 가지는 Content-Length 헤더를 갖고 있어야 한다.

데이터의 정확한 길이를 알아야 수신이 끝났는지 판별할 수 있어서이다.

### 커넥션 끊기 허용, 재시도, 멱등성

커넥션은 언제든 끊길 수 있기 때문에,  적절한 대응 준비가 되어 있어야 한다. 이때 트랜잭션을 재시도 해야 하는데, 파이프라인 커넥션에선 어려워 진다.

이때 멱등성이 있는 요청인지가 중요한데, 멱등성이 있는 메서드는 여러번 요청해도 같은 결과를 반환하기 때문이다. (GET, HEAD, PUT, DELETE, TRACE, OPTIONS) 다른 메서드는 파이프라인을 이용하면 안된다.

### 커넥션 끊는 베스트 케이스

TCP 커넥션은 양방향이기 때문에 각각의 엔드포인트에 입출력 큐가 있을 것이다.

전체 끊기 : close 헤더를 포함

절반 끊기 : shutdown()을 호출해 개별적으로 끊음

입력 채널을 끊는 것은 위험한데, 이미 끊긴 입력 채널에 데이터를 전송하면 버퍼에 저장된 정보를 전부 삭제하기 문이다.

안전하게 커넥션을 끊으려면, 출력 채널을 끊고, 다른 커넥션이 끊기기를 기다린다.
