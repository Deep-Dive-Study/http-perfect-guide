# 21. 로깅과 사용 추적

# 1. 로그란 무엇인가?

로깅은 문제를 디버깅 하거나, 통계를 내기위해 남기는 흔적이다.

보통 로그에는 트랜잭션의 기본 항목만 담는다.

- HTTP 메서드, 버전, URL
- 응답의 상태코드, 메시지 크기
- 트랜잭션이 일어난 시간
- Referer, User_Agent 헤더

# 2. 로그 포맷

HTTP 애플리케이션은 대부분 표준 로그 포맷을 한 개 이상 지원한다.

관리자는 이를 사용해 로그 통계를 추출할 수 있다.

## 2.1 일반 로그 포맷

NCSA가 정의하여 많은 서버가 기본으로 사용하는 포맷이다.

대부분의 서버가 이 포맷을 지원하며, 이 포맷을 분석하는 수많은 소프트웨어 도구가 있다.

로그 필드

- remotehost : 요청한 컴퓨터의 IP 주소
- username : ident
- auth-username : 인증된 요청자의 이름
- timestamp : 요청 날짜와 시간
- request-line : HTTP 요청 행
- response-code : 응답 상태 코드
- response-size : 응답 엔티티의 Content-Length

```sql
2009.1.32.44 - - [03/Oct/1999: 14: 16: 00 -04001 "GET / HTTP/1.0'" 200 1024
```

## 2.2 혼합 로그 포맷

아파치 같은 서버가 지원하며, 일반 로그 포맷과 매우 유사하다.

두 가지 로그 필드가 추가되었다.

- Referer : HTTP 헤더 Referer값
- User-Agent : HTTP 헤더 User-Agent값

## 2.3 넷스케이프 확장 로그 포맷

일반 로그 포맷에서 HTTP 애플리케이션 개발자들이 사용하는 여러 환경을 지원하려고 포맷을 확장했다.

프록시 관련 몇가지 로그 필드가 추가되었다.

- proxy-response-code : 트랜잭션이 프록시를 거칠 경우 서버에서 프록시로 보내는 응답코드
- proxy-response-size : 트랜잭션이 프록시를 거칠 경우 서버에서 프록시로 보내는 응답의 Content-Length
- client-request-size : 클라이언트가 프록시로 보내는 요청 본문이나 엔티티의 Content-Length
- proxy-request-size : 트랜잭션이 프록시를 거칠 경우 프록시가 서버로 보내는 요청의 본문이나 엔티티의 Content-Length
- client-request-hdr-size : 클라이언트 요청 헤더 바이트 길이
- proxy-response-hdr-size : 트랜잭션이 프록시를 거칠 경우 요청자에게 보내는 응답 헤더의 바이트 길이
- proxy-request-hdr-size : 트랜잭션이 프록시를 거칠 경우 프록시가 서버로 전송하는 요청 헤더의 바이트 길이
- server-response-hdr-size : 서버 응답 헤더의 바이트 길이
- proxy-timestmap : 트랜잭션이 프록시를 거칠 경우, 요청과 응답이 프록시를 통해 오가는 총 시간

## 2.4 넷스케이프 확장2 로그 포맷

확장 로그 포맷에서 HTTP 프록시와 웹 캐시 관련 정보를 추가했다.

다른 많은 HTTP 애플리케이션과 마찬가지로, 유연한 로그 포맷을 포함해 다양한 로그 포맷을 가지고 있다.

관리자는 이를 통해 원하는 필드로 로그를 구성할 수 있다.

몇가지 로그 필드가 추가되었다.

- route : 프록시가 클라이언트에 요청을 만드는 데 사용하는 경로
- client-finish-status-code : 클라이언트의 종료 상태 코드로, 클라이언트가 프록시로 보낸 요청이 성공적으로 완료되었는지, 인터럽트에 걸렸는지 기술한다.
- proxy-finish-status-code : 프록시가 종료된 상태로, 프록시가 서버로 보낸 요청이 완료되었는지, 인터럽트에 걸렸는지 기술한다.
- cache-result-code : 캐시 결과 코드로, 캐시가 요청에 어떻게 응답했는지 기술한다.

## 2.5 스퀴드 프록시 로그 포맷

애플리케이션, 프록시 캐시 등을 관리하기 위해 만들어진 포맷이다.

로그 필드

- timestamp : 요청이 도착한 시간
- time-elapsed :  요청과 응답이 프록시를 통해 오고 간 총 시간 (ms)
- host-ip : 클라이언트의 장비 IP
- result-code/status : result 필드와 요청 프록시가 어떤 일을 했는지 기술된다./응답 코드
- size : 프록시가 클라이언트로 보낸 HTTP 응답 헤더와 본문의 응답 바이트 길이
- method : HTTP 요청 메서드
- url : HTTP 요청 url
- rfc931-ident : 클라이언트에 인증된 사용자 이름
- hierachy/from : 넷스케이프 포맷의 경로, 필드 등 프록시가 클라이언트로 요청을 보내며 거친 경로/ 서버 이름
- content-type : 응답 엔티티의 Content-Type

# 3. 적중 계량하기

원 서버는 결산을 위해 상세 로그를 저장한다. 하지만, 캐시 레이어 때문에 요청이 원 서버까지 도달하지 않고, 캐시에서 처리된다. 이런 경우 캐시에서 처리되는 요청에 대한 로그는 누락된다.

따라서 적중 계량 규약을 통해 캐시가 정기적으로 캐시 접근을 원 서버에게 알린다.

## 3.1 개요

적중 계량 규약은 캐시와 서버가 접근 정보를 공유하고, 사용할 수 있는 캐시 리소스를 제어할 수 있는 몇 가지 기초적인 기능에 관한 HTTP 확장을 정의한다.

완벽한 해결책은 아니지만, 서버가 원하는 통계 정보를 받아올 수 있기에 사용하는 서버가 있다. (널리 사용되진 않음)

## 3.2 Meter 헤더

Meter 헤더를 통해 Cache-Control 처럼 캐시 사용량이나 보고 관련 지시를 할 수 있다.

클라이언트와 프록시 캐시 사이에 이뤄지는 트랜잭션 정보는 Meter 헤더를 통해 원 서버로 전달된다.

지시자 목록

- will-report-and-limit : 캐시 사용량 보고 후, 서버의 기술에 복종
- wont-report : 캐시 사용제한에 복종하고, 사용량 보고는 안함
- wont-limit : 캐시 사용량 보고를 하지만, 사용 제한은 없다.
- count : 사용 횟수/재사용 횟수 순으로 보고하는 지시 자료
- max-uses : 서버가 캐시를 사용해서 응답할 수 있는 최대 횟수를 기술한다.
- max-reuses : 서버가 캐시를 재사용해서 응답할 수 있는 최대 횟수를 기술한다.
- do-report : 서버가 프록시에게 사용량 보고를 요구한다.
- dont-report : 서버가 사용량 보고를 원치 않는다.
- timeout : 서버가 리소스를 계량할 때 시간 제한을 거는 데 사용한다. 캐시는 기술된 타임아웃 시간 정각이나 1분 전후로 보고를 전송해야 한다.
- wont-ask : 서버는 계량 정보를 원하지 않는다.

# 4. 개인 정보 보호에 대해

모든 HTTP 트랜잭션은 로깅되고 있기 때문에 사용자 관련 정보를 보호하는데 신경써야 한다.
