# 10. HTTP/2.0

HTTP/1.1은 구현의 단순성과 접근성에 최적화 되었다. 그래서 latency를 피할 수 없었다. 이를 개선하고자 구글의 SPDY 기반의 HTTP/2.0이 등장했다.

## 1. 개요

- TCP 위에서 동작한다.
- HTTP 헤더는 압축되어 담긴다.
- 스트림을 통해 여러 요청과 응답을 동시에 처리한다. (흐름제어 및 우선순위 부여 가능)
- 클라이언트의 요청 없이 서버에서 푸시할 수 있다.

## 2. HTTP/1.1과 차이점

### 2.1. 프레임

![image](https://github.com/Deep-Dive-Study/http-perfect-guide/assets/85796588/f5ab7ab2-ebf8-4649-9168-58a5b7031827)

- 8바이트의 헤더
    - R : 예약된 2비트 필드값, 반드시 0이어야 한다.
    - 길이 : 페이로드 길이를 나타내는 무부호 정수 (프레임 길이에 포함 안됨)
    - 종류 : 프레임의 종류
    - 플래그 : 8비트 플래그 (프레임에 따라 다른 의미)
    - 두번째 R : 예약된 1비트 필드 반드시 0이어야 한다.
    - 스트림 식별자 : 31비트 스트림 식별자 (홀수 = 클라이언트, 짝수 = 서버)
- 최대 16383바이트의 페이로드

### 2.1 스트림과 멀티플렉싱

스트림 : 클라이언트-서버 사이에서 교환되는 양방향 시퀀스

기존 방식인 HTTP/1.1에선 하나의 TCP 연결에 하나의 요청만 처리했지만, 하나의 TCP 연결에 여러 요청을 처리할 수 있게 되어 회전지연이 사라졌다.

요약

- 하나의 TCP 커넥션에서 여러 요청 처리 → 회전지연 사라짐
- 스트림 요청에 우선순위 가짐

### 2.2 헤더 압축

HTTP/1.1은 헤더가 너무 많고, 무거워서 지연과 대역폭에 영향을 끼쳤다.

HTTP/2.0부터 헤더를 압축하여 지연과 대역폭을 감소시켰다. HPACK 명세(deflate)에 따른 압축을 한다.

### 2.3 서버 푸시

HTTP/2.0부터 하나에 요청에 여러 응답을 할 수 있다.

이 뜻은 HTML, CSS, 이미지, JS를 모두 따로 전송할 수 있다는 뜻이다. → 트래픽 지연율 감소

서버 푸시를 할 땐 PUSH_PROMISE 프레임을 보내어 미리 알려줘야 한다. RST_STREAM을 사용해 푸시를 거절할 수 있다.

주의점

- 서버 푸시를 사용 하더라도, 프록시가 추가 리소스를 전달하지 않을 수 있다.
    - 반대로 아무 응답을 안했음에도 추가 리소스를 전달할 수 있다.
- 서버는 오직 안전하고, 캐시 가능하고, 본문을 포함하지 않은 요청에 대해서만 푸시 가능하다.
- 푸시할 리소스는 클라이언트가 명시적으로 보낸 요청과 연관된 것이어야 한다. (PUSH_PROMISE를 통한 스트림 이용)
- 클라이언트는 반드시 서버가 푸시한 리소스를 동일 출처 정책에 따라 검사해야 한다.
- 서버 푸시를 끄는법은 SETTING_ENABLE_PUSH를 0으로 설정하면 된다.

### 2.4 알려진 보안 이슈

- 중개자 캡슐화 공격
    - HTTP/2.0 메시지를 프록시가 HTTP/1.1 메시지로 변환할 때 메시지의 의미가 변질될 수 있다.
    - HTTP/1.1을 HTTP/2.0으로 변환할 때는 문제가 발생하지 않는다.
- 긴 커넥션 유지로 인한 개인정보 누출 우려
