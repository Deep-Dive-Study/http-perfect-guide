# 3. HTTP 메시지

## 1. 메시지 흐름

HTTP 메시지 : HTTP 애플리케이션 간 주고받는 데이터의 블록

다음으로 나올 용어들은 메시지의 방향을 뜻한다.

### 인바운드 (원 서버 방향)

메시지가 원 서버로 향하는 것을 인바운드, 
처리가 끝난 뒤에 메시지가 사용자 에이전트로 돌아오는 것을 아웃운드라고 한다.

### 다운스트림

요청 응답 가리지 않고, 강물과 같이 위에서 아래로 흐른다.

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/4b36e261-a272-46e0-bb72-1d3c2abc0a30/0782e699-107c-47aa-aa36-124c418f7c0d/Untitled.png)

위 그림에서 요청을 보면 프록시1이 프록시2한테 업스트림,  프록시3은 프록시2한테 다운스트림이다.

## 2. 메시지 부문

메시지 요소 (구성은 아래서 확인)

- 시작줄 : 모든 메시지는 시작줄로 시작한다. 요청과 응답이 포함하는 값이 다르다.
    - 메서드 : GET, POST, PUT, HEAD, TRACE, OPTIONS, DELETE 등등
    - URL : 완전한 URL 경로 구성 요소
    - 버전 : HTTPS의 버전 HTTP/<메이저>.<마이너> (메이저와 마이너는 정수) (버전은 애플리케이션이 지원하는 가장 높은 버전)
    - 상태 코드 : 요청중에 무엇이 일어났는지 설명하는 세 자리 숫자
        - 1@@ : 정보
        - 2@@ : 성공
        - 3@@ : 리다이렉션
        - 4@@ : 클라이언트 에러
        - 5@@ : 서버 에러
    - 사유 구절 : 상태 코드를 이해할 수 있게 설명하는 짧은 문구
- 헤더 (속성을 나타냄)
    - `이름 : 공백 값 CRLF(줄바꿈)` (0개 이상)
- 본문 (생략 가능) (이미지, HTML, 비디오, 트랜잭션 등등)

### 문법

```sql
요청!!
<메서드> <URL> <버전>
<헤더>
//공백필수
<본문>

응답!!
<버전> <상태코드> <사유구절>
<헤더>

<본문>
```

HTTP 0.9 버전 메시지는 조금 다르다.

- 요청 : 메서드와 URL만
- 응답 : 엔티티만

## 3. 메서드

안전한 메서드 : GET, HEAD를 뜻하며, 이 메서드들은 서버에 어떤 영향을 끼칠 수 없다.

메서드 종류

- GET : 서버에게 리소스를 요청한다.
- HEAD : GET과 행동을 같게 하지만, 헤더만 응답한다. 타입이나, 개체의 존재를 알기위해 검사한다.
- PUT : 서버에 자원을 존재한다면 수정을, 존재하지 않다면 생성을 한다.
- POST : 서버에 입력 데이터를 전송하기 위해 설계되었다.
- TRACE : 루프백을 통해 클라이언트 요청이 망가지거나 수정되었는지 확인한다.
- OPTIONS : 웹 서버가 지원하는 메서드를 알 수 있다.
- DELETE : 서버에게 리소스 삭제를 요청한다.

확장 메서드 : HTTP/1.1 명세에 정의되지 않은 메서드로 확장을 위한 메서드이다.

- LOCK : 사용자가 리소스를 잠글 수 있게 해준다. (동시성에 대한 잠금이다.)
- MKCOL : 사용자가 문서를 생성할 수 있게 해준다.
- COPY : 서버에 있는 리소스를 복사한다.
- MOVE : 서버에 있는 리소스를 옮긴다.

## 4. 상태 코드

1@@ : 정보

- 100 Continue : 서버에 엔티티 본문을 전송하기 전에 받아들이 것인지 확인하기 위해 보낸다.
    - 클라이언트는 큰 엔티티를 보내지 않으려는 목적 외에 100-continue Expect를 헤더를 보내면 안된다.
    - 서버는 100-continue Expect가 담겨져 오면 100 Continue 혹은 에러로 응답해야 한다. (다른 클라로 응답하면 안된다)
    - 프록시는 다음 홉이 HTTP/1.1을 따르거나 모른다면 전달하고, 그 이전 버전이라면 Expectation Failed를 반환한다.

2@@ : 성공

3@@ : 리다이렉션

- 리소스에 대한 복사본이 원래 서버와 아직도 동일한지 확인을 위해 사용하기도 한다. (If-Modified_Since)
- HEAD가 아닌 요청에 대해 location과 설명을 포함하는 습관을 가지자

4@@ : 클라이언트 에러

5@@ : 서버 에러

- 항상 서버의 문제는 아닐 수 있다. 게이트 웨이나, 리소스등 보조 요소의 문제일수도.

## 5. 헤더

헤더와 메서드는 클라이언트와 서버가 무엇을 하는지 결정하기 위해 함께 사용된다.

### 일반 헤더

클라이언트와 서버 모두 사용한다. (Date)

- 일반 헤더와 캐시 헤더로 나뉜다.

### 요청 헤더

요청 메시지를 위한 헤더, 요청하는 데이터 타입과 부가 정보를 제공한다.

- 요청 메시지에서만의 의미를 담는다.(클라이언트의 식별, 상태 등)
- Accept 헤더 :서버에게 클라이언트가 선호하는 응답 방식을 알려준다. (효율증대)
- 조건부 요청 헤더 : 조건에 맞는 응답을 받을 수 있다.
- 요청 보안 헤더 : 간단한 인증/응답 체계를 갖추고 있다.
- 프록시 요청 헤더 : 프록시 기능을 돕기 위해 정의된 헤더

### 응답 헤더

클라이언트에게 정보를 제공하기 위한 헤더이다. (서버 종류)

- 협상 헤더 : 서버에 표현 가능한 정보가 많은 경우 어떤 표현을 선택할지 결정하도록 한다(언어)
- 응답 보안 헤더 : 간단한 인증/응답 체계를 위한 헤더이다.

### 엔티티 헤더

엔티티 본문에 대한 헤더이다. (데이터 타입)

- 콘텐츠 헤더 : 엔티티의 크기, 구체적인 정보등을 제공한다.
- 엔티티 캐싱 헤더 : 언제 어떻게 캐시가 되어야 하는지 지시한다. 캐시의 유효성을 판단하기 위해 사용한다.

### 확장 헤더

개발자들에 의해 만들어진 비표준 헤더이다.
