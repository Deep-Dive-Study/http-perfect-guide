# 7. 캐시

캐시 : 요청에 대한 데이터 사본을 만들어 서버에 요청을 하지 않고, 사본을 제공하는 방법이다.

## 캐시의 장점

- 네트워크 비용을 줄여준다.
- 네트워크 병목을 줄인다.
- 서버에 대한 요청을 줄여 부하가 줄어든다.
- 거리로 인한 지연을 줄여준다.

### 캐시 속도

- 네트워크를 통해 서버에 요청을 하는 속도는 그 경로에서 가장 느린 네트워크 속도와 같다.
- 네트워크 라우터는 트래픽을 지연시킨다. + 빛도 속도가 있기 때문에 거리만큼 지연된다.

### 적중과 부적중

- 적중 : 캐시 요청에 대응하는 사본이 있는 경우 (정중률은 40%면 준수한편)
    - 바이트 적중률 : 응답의 크기가 다 다르기 때문에 큰 응답이 잘 히트되는게 더 중요하기 때문에 응답의 크기로 히트율을 측정한다.
- 미적중 : 요청에 대응하는 사본이 없어 원서버로 요청하는 경우
- 재검사 : 콘텐츠가 변경될 수 있어 사본이 최신인지 점검해야 하는데 이를 재검사라 한다.
    - GET 요청에 If-Modified-Since 헤더를 담아 보낸다.
    - 서버에서 객체가 변경되지 않았다면 304 응답을 보낸다.
    - 서버에서 객체가 변경되었다면 콘텐츠와 함께 200 응답을 보낸다.
    - 서버에서 객체가 삭제되었다면 404 응답을 보낸다.
    

* 적중과 미적중 구분은 Via 헤더를 통해 구분한다.

## 캐시 토폴로지

### 개인 전용 캐시

- 작고 저렴하다.
- 개인용 디스크와 메모리에 저장해둔다.

### 공용 프록시 캐시 : 프록시 서버라고 불리며 여러 사용자가 접근한다.

- 불필요한 트래픽을 줄일 수 있다.
- 프록시 서버에 저장해둔다.

### 캐시 계층

캐시에 계층을 두어 작은 캐시에서 부적중이 발생했을 때 더 큰 부모 캐시가 트래픽을 처리하도록 만든다.

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/4b36e261-a272-46e0-bb72-1d3c2abc0a30/161aeaaa-2358-43e7-a738-88c21ed91b3f/Untitled.png)

### 캐시망, 콘텐츠 라우팅, 피어링

복잡한 캐시망을 사용하며, 프록시 캐시는 어떤 부모 캐시와 대화할 것인지, 요청이 캐시를 우회할 것인지 등등 캐시 커뮤니케이션 결정을 동적으로 내린다.

결정 근거

- URL, 부모 캐시와 원 서버 중 하나를 동적으로 선택한다.
- URL에 근거하여 특정 부모 캐시를 동적으로 선택한다.
- 부모 캐시에 가기 전에 로컬 캐시를 찾아본다.
- 다른 캐시들이 캐시 콘텐츠에 부문적으로 접근을 허용하되, 인터넷 트랜짓은 허용하지 않는다.

* 인터넷 트랜짓 : 트래픽이 다른 네트워크로 건너가는 것

## 캐시 처리 단계

1. 요청 받기 : 데이터를 동시에 읽어들이고 메시지 전체가 도착하기 전에 트랜잭션 처리를 시작한다.
2. 파싱 : URL과 헤더 추출 / 이 과정을 통해 헤더 필드를 조작하기 쉽게 만든다.
3. 검색 : 로컬 복사본의 유무를 확인 / 없으면 가져와 로컬에 복사 한다.
4. 신선도 검사 : 캐시 사본이 충분히 신선한지 검사 / 신선하지 않다면, 원 서버로부터 검사한다.
5. 응답 생성 : Date 헤더에 원 서버에서 생겨난 일시를 표현한다.
6. 발송 : 프록시 서버처럼 콘텐츠 복사를 통해 데이터를 효과적으로 전송한다.
7. 로깅 : 캐시 사용에 대한 통계를 유지한다. (지표를 통해 캐시 적중율 등을 안다.)

## 신선하게 유지하기

- Cache-Control : 캐시가 만료되기까지의 시간(age)가 적혀있는 헤더
- Expires : 캐시가 만료되는 시간이 적혀있는 헤더

캐시가 만료되면 원 서버에게 변경 유무 검사를 한다.

### 조건부 GET

조건부 헤더를 추가해 캐시를 재검사한다. 이때 사용되는 헤더 옵션이 있다.

- If-Modified_Since : 가장 흔히 쓰이며, 특정 날짜 이후로 변경된 경우에 본문을 요청한다.
    - 참일시에 200과 본문이, 참이 아닐시에 304 Not Modified를 반환한다.
    - 서버에선 Last-Modified 응답 헤더를 함께 보낸다.
- If-None-Match : 변경일시로 검사하는게 적절하지 않은 상황에 쓰인다.
    - v1.1과 같이 버저닝을 한다.
- W/~~~~ : 약한 검사를 뜻한다. 어느정도 변경은 허용한다. 유의미한 변경이 있을때만 바뀐다.
- 강한 검사기 : 엔티티값이 바뀔때 반드시 같이 바뀌어야 한다.

* 서버가 Last-Modified를 포함하지 했다면 If-Modified-Since를 사용할 수 있다. 왠만하면 응답에 Last-Modified를 포함하자.

## 캐시 제어

서버에서 설정한 Cache-Control은 여러가지가 있다. 우선순위로 나열하면 다음과 같다.

- no-store : 검증되지 않은 캐시는 응답되지 않도록 막는다. / 캐시로 저장되는 것을 막는다.
- no-cache : 검증되지 않은 캐시는 응답되지 않도록 막는다.
- must-revalidate : 캐시가 신선하지 않으면, 재검사 없이는 제공하지 않는다.
- max-age : 에이지(초) 만큼 지나면 캐시는 서버에게 제공할 수 없다.
- Expires : deprecated되었으며, 실제 만료 날짜를 명시한다.
- 아무 것도 첨부하지 않으면 : LM알고리즘을 사용해 age를 결정한다.

### 신선도 제약

캐시의 만료를 업격하거나 느슨하게 관리할 수 있는데, 이를 위한 지시어가 있다.

- max-stale = [S] : 캐시가 신선하지 않아도 자유롭게 제공한다. / S만큼 지난 문서도 받는다.
- min-fresh = [S] : 지금부터 S초동안 신선한 문서만 받아들인다.
- max-age = [S] = 캐시는 S초보다 오래된 캐시를 반환할 수 없다.
- no-cache : 캐시된 리소스는 재검사하기 전에 받아들이지 않는다.
- no-store : 민감한 정보가 포함되어 최대한 빨리 삭제해야 한다.
- only-if-cached : 캐시에 들어있는 정보만 원한다. (원서버로 요청x)

이 밑으로 오래된 기술이니 읽어보고 넘어가자

### 캐시 제어 설정

아파치

- mod_headers : 모듈이 개별 헤더를 설정하게 해준다.
- mod_expire : expires 헤더 자동 생성한다.
- mod_cern_meta : HTTP 헤더들을 특정 객체와 연결시킨다.

- HTTP-EQUIV : 웹 서버 설정 파일과 상호작용 없이 HTML문서에 HTTP 헤더 정보를 부여한다.

### 알고리즘

나이와 신선도는 캐시가 유효한지 파악하는데 중요한 지표이다.

- 나이 계산 : 출발하고부터 지난 시간을 뜻한다. 여러 계산식이 있다.
    - 겉보기 나이 : 현재 시간에서 Date 헤더 값을 뺸 것
    - 점층적 나이 : 네트워크를 거치며 Age 헤더에 값을 추가한다. 따라서 나이를 추정값으로 표현한다.
    - 완벽한 계산법 : 클라이언트에게 도착했을 때 나이 + 도착하고 지난 시간
- 신선도 계산
    - 완벽한 계산 알고리즘 : 펄 알고리즘 (서버에서 도달할 수 있는 최대 나이)

## 캐시 측정

로그 마이그레이션 - 로그를 통해 원서버에 가지 않더라도 요청을 모니터링할 수 있다.

Simple Hit-Metering and Usage-Limiting for HTTP : 캐시 적중 회수를 정기적으로 서버에게 보내준다.
