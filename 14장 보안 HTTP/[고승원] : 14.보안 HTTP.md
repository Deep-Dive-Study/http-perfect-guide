# 14. 보안 HTTP

## 1. HTTP를 안전하게 만들기

HTTP 보안 버전은 효율이 좋고, 이식성이 좋아야하며 동시에 관리가 쉬워야 된다.

- 서버 인증 - 진짜 서버인지 인증한다.
- 클라이언트 인증 - 진짜 사용자인지 인증한다.
- 무결성 - 데이터가 위조되는 것으로부터 안전해야 한다.
- 암호화 - 클라이언트와 서버는 도청에 대한 걱정 없이 대화할 수 있어야 한다.
- 효율 - 저렴한 클라이언트나 서버도 이용할 수 있도록 충분히 빨라야 한다.
- 편재성 - 거의 모든 클라이언트와 서버에 지원되어야 한다.
- 관리 확장성 - 누구든 어디서든 언제든 즉각적인 보안 통신을 할 수 있어야 한다.
- 적응성 - 현재 알려진 최선의 보안 방법을 지원해야 한다.
- 사회적 생존성 - 사회의 문화적 정치적 요구를 만족시켜야 한다.

### 1.1 HTTPS

HTTPS는 HTTP에 SSL(TLS) 계층이 추가된 것을 뜻한다.

![image](https://github.com/Deep-Dive-Study/http-perfect-guide/assets/85796588/3f470138-39dd-44e3-83c5-073f708f2875)

## 2. 디지털 암호학

대칭키 : 인코딩 디코딩 같은 키를 사용함

비대칭키 : 인코딩 디코딩 다른 키를 사용함

공개키 : 비밀 메시지를 전달하는 수백만 대의 컴퓨터를 쉽게 만들 수 있는 시스템

디지털 서명 : 메시지가 위조 혹은 변조되지 않았음을 입증하는 체크섬

디지털 인증서 : 신뢰할 만한 조직에 의해 서명되고 검증된 신원 확인 정보

암호화 알고리즘은 간단히 시작되었지만, 점점 발전하여 기계가 대신하고, 키가 있는 암호화 방법을 사용한다.

- 속도 및 기능 한계 돌파 → 다양한 방법 사용 가능
- 키의 크기가 점점 커져 키 크래킹이 어려워짐

## 3. 대칭키 암호법

인코딩과 디코딩 키가 같다. (DES, AES등)

### 3.1 키 길이와 열거 공격

열거 공격 : 가능한 키 값을 시도해 보는 것 (40비트 기준 1조개)

### 3.2 공유키 발급

수신자와 발신자가 대화하려면 둘 다 공유 키를 가져야 한다.

공유키를 안전하게 수신하기 위해선 개인 키를 발급받아야 한다.

대화하는 사용자마다 다른 공유키를 가져야 한다.

## 4. 공개키 암호법

두개의 비대칭 키를 사용하여 하나는 인코딩, 하나는 디코딩을 위한 것이다. (RSA, DSA등)

인코딩 키는 공개되어 공개 키라는 이름으로도 불리고, 디코딩 키는 호스트만 알고있다.

노드가 많아져도 키쌍이 많아지지 않는다.

RSA는 소수를 계산하는 방법이어서 뚫기 어렵다.

### 4.2 혼성 암호 체계와 세션 키

- 공개키 암호법은 안전한 소통 전에 개인 키에 대한 협상을 안해도 된다.
- 알고리즘 계산이 공개키에 비해 느린편이다.
- 따라서 대칭과 비대칭을 섰는다. (채널수립은 비대칭키, 그 이후 대칭키)

## 5. 디지털 서명

메시지에 대해 암복호화 외에도 누가 메시지를 썼고, 메시지가 위조되었는지 증명할 수 있도록 한다.

### 5.1 서명은 암호 체크섬이다

- 서명은 메시지의 저자를 알려준다. 저자만이 저자의 개인키로 체크섬을 계산할 수 있다.
- 타인이 메시지를 수정하면 체크섬이 변경되기 때문에 체크섬이 달라진다.
- 서명은 보통 비대칭 공개키에 의해 생성된다.

서명 flow

- 메시지를 전송할 때 digest에 서명 함수를 적용하여 보낸다.
- 수신자만 개인 키를 알고 있기 때문에 복호화 하여 서명을 검사한다.

## 6. 디지털 인증서

디지털 인증서는 신뢰할 수 있는 기관에서 보증 받은 사용자나 회사의 정보를 갖고 있다. (certs라고 불림)

### 6.1 인증서 내부

- 대상의 이름
- 유효 기간
- 인증서 발급자 (보증 기관)
- 인증서 발급자의 디지털 서명
- 서명 알고리즘과 대상의 공개키

![image](https://github.com/Deep-Dive-Study/http-perfect-guide/assets/85796588/93f4e85a-febe-48d6-87ab-91539bdabf61)

### 6.2 X.509 v3 인증서

인증서 표준은 없지만 대부분 X.509 서식에 저장되고 있다.

- 버전 : 보통은 3
- 일련 번호 : 인증기관이 생성한 정수, 고유한 값을 가져야함
- 서명 알고리즘 ID
- 인증서 발급자
- 유효 기간
- 대상의 이름 : 인증서에 기술된 사람이나 조직
- 대상의 공개키 정보
- 발급자 고유 식별자
- 대상의 고유 식별자
- 인증기관 서명

### 6.3 서버 인증을 위해 인증서 사용하기

HTTPS를 통해 트랜잭션을 시작하면 브라우저는 자동으로 접속한 서버에서 디지털 인증서를 가져온다.

- 인증서를 받아온다.
- 서명 기관을 검사한다.
- 서명 기관의 공개키를 통해 메시지 체크섬을 한다.

## 7. HTTPS의 세부사항

HTTPS 는 매우 안전하고 유연해서 인터넷 애플리케이션의 고속 성장을 만들었다.

HTTPS의 보안 계층은 SSL/TLS이라 불리며 어떻게 불리든 같은 의미를 가진다.

### 7.2 스킴

HTTPS는 옵셔널하기 때문에 http와 https라는 접두사를 통해 구별한다.

http의 기본 포트는 80포트이고, https의 기본 포트는 443이다.

https는 바이너리 프로토콜이기 때문에 http와 해석하는 방법이 상이하다.

### 7.3 보안 전송 셋업

HTTP

- 웹 서버의 80포트로 TCP 커넥션을 열고
- 요청/응답
- 커넥션을 닫는다.

HTTPS

- 웹 서버의 443포트로 TCP 커넥션을 연다.
- 서로의 암호법 매개변수와 교환 키를 협상하며 SSL 계층을 초기화 한다.
- TCP계층에 가기 전에 암호화되어 요청/응답
- SSL커넥션, TCP 커넥션을 순서대로 닫는다.

### 7.4 SSL 핸드셰이크

flow

1. 클라이언트가 암호 후보를 보내고 인증서를 요구한다.
2. 서버는 암호를 선택하고, 인증서를 응답한다.
3. 클라이언트가 비밀 정보를 보내고, 클라이언트와 서버는 대칭키를 만든다.
4. 클라이언트와 서버는 서로에게 암호화를 시작한다고 알린다.

### 7.5 서버 인증서

SSL은 서버 인증서를 클라이언트로 전달하고 다시 클라이언트 인증서를 서버로 전달한다.

HTTPS 트랜잭션은 항상 서버 인증서를 요구한다.

서버 인증서에는 조직의 이름, 주소, 서버 DNS 도메인 등등이 담겨져 있다.

### 7.6 사이트 인증서 검사

웹 브라우저 검사기법 수행단계

- 날짜 검사 : 인증서가 활성화 전이거나, 만료 후인지 검사한다.
- 서명자 신뢰도 검사 : 모든 인증서는 CA 서명이 되어있다. 신뢰할만한 CA가 서명했다면 올바른 인증서라고 판단할 수 있다.
- 서명 검사 : CA가 올바르다 판단되면, CA의 공개키로 서명에 적용하여 체크섬을 비교한다.
- 사이트 신원 검사 : 트래픽이 가로챔당하지 않게, 대화중인 서버의 도메인 이름을 비교한다.

### 7.7 가상 호스팅과 인증서

가상 호스트로 운영되는 사이트의 보안 트래픽 핸들링은 까다롭기도 하다.

사용자가 인증서 이름과 다른 가상 호스트에 도착했다면 경고가 나타나기 때문이다.

- 이 문제는 보안 트랜잭션의 시작을 해당하는 호스트로 리다이렉트 시킨다.

# 8. 진짜 HTTPS 클라이언트

SSL은 복잡한 바이너리 프로토콜이기 때문에 직접 처리하는건 상당히 어렵다.

### 8.1 OpenSSL

SSL/TLS의 가장 인기있는 오픈소스이다.

### 8.2 간단한 HTTPS 클라이언트

OpenSSL 패키지를 사용해서 HTTPS 클라이언트를 만들어보자

1. SSL 라이브러리를 초기화 한다.
2. 서버의 호스트 명을 IP로 변환한다.
3. 서버와 443포트로 TCP커넥션을 연다.
4. TCP 커넥션을 통해 SSL 핸드셰이크를 만든다.
    1. 협상을 통해 선택된 암호를 출력한다.
    2. 서버 인증서를 출력한다.
5. SSL을 통해 HTTP 요청을 보낸다.
6. 요청과 응답이 끝났으면 커넥션을 닫는다.

# 9. 프록시를 통한 보안 트래픽 터널링

외부로부터 서버에 접근하는 요청을 프록시를 통해서 바이러스 검사나 콘텐츠 제어등을 수행할 수 있다.

이는 클라이언트가 서버로 데이터를 보낼때 서버의 공개키로 암호화하면 프록시가 HTTP 헤더를 읽을 수 없게 된다.

그래서 나온 방법이 SSL 터널링이다.

- 클라이언트는 프록시에게 자신이 연결하고자 하는 안전한 호스트와 포트를 말해준다.
- 이 내용을 CONNECT 메서드로 암호화가 시작되기 전에 프록시에게 전달한다.
- CONNECT 메서드는 클라이언트와 서버 사이에 터널을 만들어준다.
    - 호스트명:포트”공백” HTTP 버전
    - 헤더
    - CRLF
    - SSL
- 이후 핸드셰이크가 성공하면 SSL 데이터 전송이 시작된다.
