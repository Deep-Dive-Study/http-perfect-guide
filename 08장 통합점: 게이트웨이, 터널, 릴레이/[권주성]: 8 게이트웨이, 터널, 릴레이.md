# 8장. 통합점: 게이트웨이, 터널, 릴레이
- 사람들은 HTTP를 통해 더욱 복잡한 리소스를 공유하기를 원함

- **용어 정리**
  - `게이트웨이`: 서로 다른 프로토콜과 애플리케이션 간의 HTTP 인터페이스
  - `애플리케이션 인터페이스`: 서로 다른 형식의 웹 애플리케이션이 통신하는데 사용됨
  - `터널`: HTTP 커넥션을 통해서 HTTP 가 아닌 트래픽을 전송하는데 사용함
  - `릴레이`: 단순한 HTTP 프락시로, 한 번에 한 개의 홉에 데이터를 전달하는데 사용함

## 8.1 게이트웨이 
- **`리소스와 애플리케이션을 연결하는 역할`**
  - 웹에 복잡한 리소스를 올려야 할 필요가 생기면서, 모든 리소스를 한 개의 애프리케이션으로만 처리할 수 없다는 것은 분명해짐

  - 이 문제를 해결하기 위해 인터프리터 같이 **`리소스를 받기 위한 경로를 안내하는 역할`** 을 하는 게이트웨이를 고안해냄

    <img width="398" alt="image" src="https://github.com/Deep-Dive-Study/http-perfect-guide/assets/99165624/7e2989bb-3d25-409f-9264-5f2f4a4caa5d">

- 요청을 받고 응답을 보내는 `포털`처럼 동작하는데, 동적인 콘텐츠를 생성하거나 데이터베이스에 질의를 보낼 수 있음

- **HTTP 트래픽을 다른 프로토콜로 자동으로 변환하여, HTTP 클라이언트가 다른 프로토콜을 알 필요 없이 서버에 접속할 수 있게 하기도 함**

<img width="401" alt="image" src="https://github.com/Deep-Dive-Study/http-perfect-guide/assets/99165624/91dafa1a-231d-4520-8a55-84cac136b51b">

- 그림 8-2c에서 게이트웨이는 애플리케이션 서버 게이트웨이 API를 통해서 HTTP 클라이언트를 서버 측 애플리케이션 프로그램에 연결함
  - 역할적 측면(관점)의 인터페이스 

- 상이한 HTTP 버전 사이에 변환을 수행하는 웹 프락시도 게이트웨이와 같음

### 8.1.1 클라이언트 측 게이트웨이와 서버 측 게이트웨이
- 웹 게이트웨이는 한쪽에서는 HTTP 로 통신하고 다른 한쪽에서는 HTTP 가 아닌 다른 프로토콜로 통신함

- 클라이언트 측 프로토콜과 서버 측 프로토콜을 **`/`** 으로 구분해 기술함

```text
<클라이언트 프로토콜>/<서버 프로토콜>
```

- 서버 측 게이트웨이: 서버 <-> 클라 (HTTP 프로토콜 통신) / 서버 <-> 서버 (외래 프로토콜)
- 클라이언트 측 게이트웨이: 클라 <-> 서버 (HTTP) / 클라 <-> 클라 (외래 프로토콜)

## 8.2 프로토콜 게이트웨이 
- 게이트웨이에 HTTP 트래픽을 바로 보낼 수 있음
  - 브라우저에 명시하거나, 게이트웨이를 대리 서버(리버스 프락시)로 설정할 수 있음
  
  <img width="395" alt="image" src="https://github.com/Deep-Dive-Study/http-perfect-guide/assets/99165624/3a37d2f1-1061-4926-bb6d-27968aae36c7">

### 8.2.1 HTTP/*: 서버 측 웹 게이트웨이 
- 서버 측 웹 게이트웨이는 클라이언트로부터 HTTP 요청이 원 서버 영역으로 들어오는 시점에 클라이언트 측의 HTTP 요청을 외래 프로토콜로 전환

  <img width="405" alt="image" src="https://github.com/Deep-Dive-Study/http-perfect-guide/assets/99165624/892e4300-1ec3-42cc-8c9a-64b89b4f1afc">

### 8.2.2 HTTP/HTTPS: 서버 측 보안 게이트웨이
- 모든 웹 요청을 암호화함으로써 개인 정보 보호와 보안을 제공하는데 게이트웨이를 사용할 수 있음

- 클라이언트는 일반 HTTP 를 사용하여 웹을 탐색 할 수 있지만, 게이트웨이는 자동으로 사용자의 모든 세션을 암호화할 것

  <img width="401" alt="image" src="https://github.com/Deep-Dive-Study/http-perfect-guide/assets/99165624/7fefaf40-a8fb-4b5b-aec9-4f89b17cb0b0">

### 8.2.3 HTTPS/HTTP: 클라이언트 측 보안 가속 게이트웨이 
- HTTPS/HTTP 게이트웨이는 웹 서버의 앞단에 위치하고, 보이지 않는 인터셉트 게이트웨이나 리버스 프락시 역할을 함
  - 보안 가속기

- 게이트웨이는 보안 HTTPS 트래픽을 받아서 복호화하고, 웹 서버로 보낼 일반 HTTP 요청을 만듬

- 원 서버보다 더욱 효율적으로 보안 트래픽을 복호화하는 암호화 하드웨어를 내장해서 원 서버의 부하를 줄여주기도 함

- 게이트웨이와 원 서버 간의 암호화하지 않은 트래픽을 전송하기 때문에, 게이트웨이와 원 서버 간에 있는 네트워크가 안전한지 확인을 하고 사용해야함

  <img width="410" alt="image" src="https://github.com/Deep-Dive-Study/http-perfect-guide/assets/99165624/3ae072da-c177-4922-bfc4-5696ff5cff49">

## 8.3 리소스 게이트웨이 
- 게이트웨이의 가장 일반적인 형태인 애플리케이션 서버는 **`목적지 서버와 게이트웨이를 한 개의 서버로 결합함`**

- 애플리케이션 서버는 HTTP 를 통해서 클라이언트와 통신하고 서버 측에 있는 애플리케이션 프로그램에 연결하는 서버 측 게이트웨이
  - 게이트웨이의 API를 통해서 요청을 서버에서 동작하고 있는 애플리케이션에게 전달함

  <img width="405" alt="image" src="https://github.com/Deep-Dive-Study/http-perfect-guide/assets/99165624/6882cd5f-392a-4880-97c7-5495703516da">

- 최초의 API는 공용 게이트웨이 인터페이스인 CGI
  - 웹 서버가 사용하는 표준화된 인터페이스 집합

- 서버와 게이트웨이는 별개의 애플리케이션이기 때문에 각각 가지고 있는 책임이 나뉘어져 있음 

  <img width="393" alt="image" src="https://github.com/Deep-Dive-Study/http-perfect-guide/assets/99165624/a768c58e-b575-47e7-880e-36e9a050fc5c">

### 8.3.1 공용 게이트웨이 인터페이스 
- 공용 게이트웨이 인터페이스 (CGI) 는 **`최초의 서버 확장이자 지금까지도 가장 널리 쓰이는 서버 확장`**

- 웹에서 동적인 HTML, 신용카드, 데이터베이스 질의 등을 제공하는데 쓰임

- 서버와 CGI 애플리케이션 간에 진행되는 처리 단계를 감춤
  - 클라이언트가 CGI 애플리케이션이 무언가를 하고 있다는 것을 알 수 있는 유일한 단서는 URL 에 있는 'cgi' 혹은 '?' 같은 것들 뿐임

- CGI 는 모든 요청마다 새로운 프로세스를 만드는데 따르는 부하가 꽤 크고 사용하는 서버의 성능을 제한하며 서버 장비에 부담을 줌

- 이런 문제를 해결하기 위해 데몬으로 동작하는 Fast CGI 가 개발되었음

### 8.3.2 서버 확장 API
- 서버 자체의 동작을 바꾸고 싶거나 혹은 서버의 처리능력을 최고치로 끌어 올리고자 할 때 
  - 이러한 두 가지 필요성에 서버 개발자는 웹 개발자가 자신의 모듈을 HTTP 와 직접 연결할 수 있는 강력한 인터페이스인 서버 확장 API 를 제공하였음

- 확장 API 는 프로그래머가 자신의 코드를 서버에 연결하거나 서버의 컴포넌트를 자신이 만든 것으로 교체해버릴 수 있게 하였음

## 8.4 애플리케이션 인터페이스와 웹 서비스
- 웹 애플리케이션이 더 많은 형식의 서비스를 제공함에 따라 HTTP가 애플리케이션을 연결하는 도구로 활용할 수 있음이 더 확실해짐 

- 애플리케이션을 연결하면서 생기는 까다로운 이슈 중 하나는, **데이터를 교환하려는 두 애플리케이션 사이에서 프로토콜 인터페이스** 를 맞추는 일임

- 웹 서비스는 SOAP 을 통해 XML 을 사용하여 정보를 교환함
  - XML 은 데이터 객체를 담는 데이터를 생성하고 해석하는 방식을 제공

- SOAP 는 HTTP 메시지에 XML 데이터를 담는 방식에 관한 표준

- 현대에는 SOAP 보단 **`REST`** 방식이 많이 활용되며, 데이터 포맷도 XML 대신 **`JSON`** 을 주로 사용함

## 8.5 터널
- **웹 터널은 HTTP 프로토콜을 지원하지 않는 애플리케이션에 HTTP 애플리케이션을 사용해 접근하는 방법을 제공함**

- 웹 터널을 사용하면 HTTP 커넥션을 통해서 HTTP 가 아닌 트래픽을 전송할 수 있고, 다른 프로토콜을 HTTP 위에 올릴 수 있음

  <img width="401" alt="image" src="https://github.com/Deep-Dive-Study/http-perfect-guide/assets/99165624/1537f1f5-7f60-407c-802f-d73ba0a412c5">

### 8.5.1 CONNECT 로 HTTP 터널 커넥션 맺기
- 웹 터널은 HTTP 의 `CONNECT` 메서드를 사용하여 커넥션을 맺음

- CONNECT 메서드는 터널 게이트웨이가 임의의 목적 서버와 포트에 TCP 커넥션을 맺고 클라이언트와 서버 간에 오는 데이터를 무조건 전달하기를 요청함

  <img width="397" alt="image" src="https://github.com/Deep-Dive-Study/http-perfect-guide/assets/99165624/c8d43540-0fca-4991-a55a-f15456b0192b">

    - 클라이언트 → 게이트웨이 CONNECT 요청 (터널 연결 요청 - SSL 433 포트)
    - TCP 커넥션 생성 
    - 게이트웨이 → 클라이언트에게 200 connection Established 응답 전송하여 연결되었음을 알림
    - 터널 연결 
    - 양방향 데이터 전달 

#### CONNECT 요청
- 요청 URI 는 호스트명이 대신하며 콜론에 이어 포트를 기술함

```
CONNECT xxxx:443 HTTP/1.0
User-agent: xxx
```

#### CONNECT 응답
- 클라이언트는 요청을 전송한 다음, 게이트웨이의 응답을 기다람
  - 일반 HTTP 메시지와 같이 200 응답 코드는 성공을 뜻함

```
HTTP/1.0 200 Connection Established
```

- 일반적인 응답과 달리 Content-Type 헤더를 포함할 필요는 없음

### 8.5.2 데이터 터널링, 시간, 커넥션 관리 
- 터널을 통해 전달되는 데이터는 게이트웨이에서 볼 수 없어서, 게이트웨이는 패킷의 순서나 흐름에 대해 어떤 가정도 할 수 없음

- 클라이언트는 성능을 높이기 위해 CONNECT 요청을 보낸 다음, 응답을 받기전에 터널 데이터를 전송할 수 있음

- 게이트웨이는 네트워크 I/O 요청이 헤더 데이터만을 반환해줄 거라고 가정할 수 없어서, 게이트웨이는 커넥션이 맺어지는 대로 헤더를 포함해서 읽어들인 모든 데이터를 서버에 전송해야함

- 요청 후에 터널을 통해 데이터를 전송한 클라이언트는 인증요구나 200 외의 응답이 와을 때 요청 데이터를 다시 보낼 준비가 되어 있어야함

- 커넥션이 끊긴 한쪽에 아직 전송하지 않은 데이터는 버려짐

### 8.5.3 SSL 터널링
- 웹 터널은 원래 방화벽을 통해서 암호화된 SSL 트래픽을 전달하려고 개발되었음

- SSL 같이 암호화된 프로토콜은 정보가 암호화되어 있기 때문에 낡은 방식의 프락시에서는 처리되지 않음

  <img width="399" alt="image" src="https://github.com/Deep-Dive-Study/http-perfect-guide/assets/99165624/116d8ee4-eb16-4877-bdad-2497e9c684c4">

- 터널을 사용하면 SSL 트래픽을 HTTP 커넥션으로 전송하여 80 포트의 HTTP 만을 허용하는 방화벽을 통과시킬 수 있음

- 이는 악의적인 트래픽이 사내로 유입되는 경로가 될 수도 있음

  <img width="396" alt="image" src="https://github.com/Deep-Dive-Study/http-perfect-guide/assets/99165624/815e8c8f-6fcc-423b-94e5-6f9787e0211f">

### 8.5.4 SSL 터널링 vs HTTP/HTTPS 게이트웨이
- HTTPS 프로토콜은 다른 프로토콜과 같은 방식으로 게이트웨이를 통과할 수 있음 

- 원격 HTTPS 서버와 SSL 세션을 시작하는 게이트웨이를 두고 클라이언트 측의 HTTPS 트랜잭션을 수행하는 방식

- 응답은 프락시가 받아서 복호화하고 난 후에 HTTP 를 통해 클라이언트로 전송

- **`단점`**
  - 클라이언트-게이트웨이 사이에는 보안이 적용되지 않은 일반 HTTP 커넥션이 맺어져있음
  - 프락시가 인증을 담당하고 있기 때문에, 클라이언트는 원격 서버에 SSL 클라이언트 인증을 할 수 없음
  - 게이트웨이는 SSL 을 완벽히 지원해야함

→ 이 상황에서 SSL 터널링을 사용하면 프락시에 SSL 을 구현할 필요가 없음. 즉, 프락시 서버는 트랜잭션의 보안에는 관여하지 않고 암호화된 데이터를 그대로 터널링할 뿐임

### 8.5.5 터널 인증
- HTTP 다른 기능들은 터널과 함께 적절히 사용될 수 있음
  
- 프락시 인증 기능은, 클라이언트가 터널을 사용할 수 있는 권한을 검사하는 용도로 터널에서 사용함

  <img width="405" alt="image" src="https://github.com/Deep-Dive-Study/http-perfect-guide/assets/99165624/75ea9bb0-cfc7-4ee7-9298-7eaf106bfc65">

### 8.5.6 터널 보안에 대한 고려사항들
- 터널 게이트웨이는 통신하고 있는 프로토콜이 터널을 올바른 용도로 사용하고 있는지 검증할 방법이 없음

- 터널의 오용을 최소화하기 위해서, **게이트웨이는 HTTPS 전용 포트인 443 같이 잘 알려진 특정 포트만을 터널링할 수 있게 허용해아함**

## 8.6 릴레이
- HTTP 릴레이는 명세를 완전히 준수하지는 않는 간단한 **`HTTP 프락시`**

- 커넥션을 맺기 위한 HTTP 통신을 한 다음, 바이트를 맹목적으로 전달함

- 단순 맹목적 릴레이를 구현하는데 관련된 더 일반적인 문제 중 하나는, 맹목적 릴레이가 Connection 헤더를 제대로 처리하지 못해서 keep-alive 커넥션이 행에 걸리는 것

  <img width="394" alt="image" src="https://github.com/Deep-Dive-Study/http-perfect-guide/assets/99165624/a50869e0-ba60-4046-bcca-a6614e727a05">

- 여러 문제를 예방하기 위해서 HTTP 를 제대로 준수하는 프락시를 사용하는게 좋음
  - 사용시 주의해야함 
