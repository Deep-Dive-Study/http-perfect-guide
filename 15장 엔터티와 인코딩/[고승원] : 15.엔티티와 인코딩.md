# 15. 엔티티와 인코딩

HTTP는 콘텐츠를 나르기 위해 잘 라벨링된 엔티티를 사용한다.

# 1. 메시지는 컨테이너, 엔티티는 화물

![image](https://github.com/Deep-Dive-Study/http-perfect-guide/assets/85796588/dc9817f8-ff21-40dd-b876-d5a12e60203f)

메시지 엔티티(body)는 엔티티 헤더와 엔티티 본문으로 이루어진다. 이는 CRLF로 구분된다.

- Content-Type : 엔터티에 의해 전달된 객체의 종류
- Content-Length : 전달되는 메시지의 길이나 크기
- Content-Language : 전달되는 객체와 가장 잘 대응되는 자연어
- Content-Encoding : 객체 데이터에 대해 행해진 변형(압축등)
- Content-Location : 요청 시점을 기준으로 객체의 또 다른 위치
- Content-Range : 만약 이 엔터티가 부분 엔터티라면, 이 헤더는 이 엔터티가 전체에서 어느 부분에 해당하는지정의한다.
- Content-MD5 : 엔터티 본문의 콘텐츠에 대한 체크섬
- Last-Modified : 서버에서 이 콘텐츠가생성 혹은수정된날
- Expires : 이 엔터티 데이터가 더이상 신선하지 않은것으로 간주되기 시작하는 날짜와시각
- Allow : 이 리소스에 대해 어떤 요청 메서드가 허용되는지. 예)GET과 HEAD
- ETag : 이 인스턴스에 대한 고유한 검사기. 엄밀히 말해 ETag 헤더는 엔터티 헤더로 정의 되어 있지는않지만 엔터티와 관련된 많은 동작을 위해 중요한 헤더이다.
- Cache-Control : 어떻게 이 문서가 캐시될 수 있는지에 대한 지시자. ETag 헤더와 마찬가지로 Cache-Control 헤더도 엔터티 헤더로 정의되어 있지는 않다.

### 1.1 엔티티 본문

다른 정보는 헤더에 있기 때문에 엔티티 본문은 가공되지 않은 데이터만 가지고 있다.

- 본문에 대한 데이터를 해석하기 위해 헤더에 설명이 붙는다.
- 헤더와 본문은 CRLF으로 구분되어 바로 CRLF 바로 다음부터 본문이 시작된다.

# 2. Content-Length

Content-Length : 엔티티 본문의 크기를 바이트 단위로 나타낸다. 

- 청크 인코딩이 아닌 이상 필수 값이다.
- 잘림 검출 : Content-Length가 없으면 HTTP 커넥션이 닫힌지, 충돌이 발생한지 구분이 안된다.
- 잘못된 Content-Length : 몇몇 서버와 프록시는 오동작은 탐지하고 사용자에게 알려준다.
- Content-Length와 지속 커넥션 : 지속 커넥션을 위해 필수적인 요소이다.
    - Content-Length 헤더가 커넥션이 닫히지 않도록 한다.
- 콘텐츠 인코딩 : Content-Length는 인코딩된 본문의 길이를 나타낸다.
- 엔티티 본문 길이 판별 규칙
    - 본문을 갖는 것이 허용되지 않는 HTTP 메시지의 Content-Length 헤더는 무시된다. (HEAD)
    - Transfer-Encoding 헤더를 포함한다면 0바이트 청크로 커넥션을 끝내야 한다.
    - 메시지가 Content-Length 헤더를 갖는다면 Transfer-Encoding 헤더가 존재하지 않는이상 본문의 길이를 담는다.
    - 메시지가 multipart/byteranges 타입이고 Content-Length가 없다면 각자 스스로 크기를 정의한다.
    - 위의 모든 규칙에도 해당되지 않으면 엔티티는 커넥션이 닫힐 때 끝난다. 오직 서버만 끊기 가능
    - HTTP/1.0과 HTTP/1.1의 호환을 위해 Content-Length는 필수적이다.

* `Transfer-Encoding`은 메시지의 전송 코딩 방식을 나타냄, 서버가 리소스를 클라이언트에게 전송할 때 어떤 인코딩 방식을 사용하는지 명시한다. (chunked, gzip)

# 3. 엔티티 요약

엔티티는 변경 감지를 위한 체크섬과 암호화를 할 수 있다.

불완전한 트랜스코딩, 버그 등의 이유로 엔티티 본문이 변형되는 일이 발생한다. 이 변경을 감지하기 위해 최초의 엔티티가 생성될 때 체크섬을 생성할 수 있으며, 수신자는 체크섬 검사를 할 수 있다.

Content-MD5 헤더는 엔티티 본문에 MD5 알고리즘을 적용한 결과를 보내기 위해 사용된다. 오직 응답을 처음 만든 서버만이 이 헤더를 계산해서 보낸다.

# 4. 미디어 타입과 Charset

Content-Type 헤더 필드는 엔티티 본문의 MIME 타입을 기술한다.

MIME : 주 미디어 타입 / 부 타입으로 구성되어있음 (text/html, image/gif 등)

- 텍스트를 위한 문자 인코딩
    
    내용을 더 자세히 지정하기 위해 Optional한 매개변수를 지원한다.
    

Content-Type: text/html; charset=iso-8859-4

- 멀티파트 미디어 타입
    
    서로 붙어있는 여러개의 메시지를 포함해 복합 메시지로 보낸다. (구성원은 문자열로 식별)
    
- 멀티파트 폼 제출
    
    다른 종류와 길이의 값으로 채워진 폼을 뜻한다.
    
    multipart/form-data 또는 multipart/mixed로 사용된다.
    
    여기서 매개변수로 boundary를 추가하는데, 이는 본문의 구분자로 사용된다.
    
- 멀티파트 범위 응답
    
    multipart/byteranges 헤더를 사용하며 각각 다른 범위를 담고있는 본문이 온다.
    

# 5. 콘텐츠 인코딩

인코딩 종류는 압축과 암호화가 있다.

### 콘텐츠 인코딩 과정

- 원본에 대한 Content-Type, Content-Length 헤더와 응답 메시지를 생성한다.
- 인코딩 서버가 인코딩 메시지를 생성한다. (Content-Length가 달라질 수 있다.)
- 수신측은 디코딩한다.

### 콘텐츠 인코딩 유형

인코딩은 각 콘텐츠 인코딩 알고리즘에 고유한 토큰을 할당하는 IANA를 통해 표준화된다.

- gzip : 엔티티에 GNU zip 인코딩 적용
- compress : 유닉스 파일 압축 프로그램인 compress사용
- deflate : zlib 포맷으로 압축
- identity : 엔티티에 어떤 인코딩도 수행되지 않았음을 의미. (Content-Encoding이 없으면 디폴트)

### Accept-Encoding 헤더

서버가 지원하지 않는 인코딩 사용 방지를 위해 클라이언트가 유효한 방식을 전달하는 용도이다.

0.0 부터 1.0으로 선호하는 방식을 표현할 수 있다. (1.0이 최고)

# 6. 전송 인코딩과 청크 인코딩

전송 인코딩은 보통 바디만 인코딩하고, 청크 인코딩은 전체 메시지에 대해 적용된다.

### 안전한 전송

- 게이트웨이는 본문의 최종 크기를 판단할 수 없다. Content-Length를 종결 꼬릿말로 데이터를 보낸다.
- 인코딩 방식을 알아보기 어렵고, SSL이 잘되어 있기 때문에 흔하지 않다.
- Transfer-Encoding : 안전한 전송을 위해 어떤 인코딩이 적용되었는지 알려준다.
- TE : 어떤 확장된 전송 인코딩을 사용할 수 있는지 서버에게 알려주기 위해 요청 헤더에 사용한다. (chunked, trailers)

### 청크 인코딩

메시지를 일정 크기의 청크로 쪼개어 각 청크를 순차적으로 보낸다.

이를 사용하면 메시지를 보내기 전에 전체 크기를 알 필요가 없다.

- 청크와 지속 커넥션
    
    지속 커넥션은 본문을 쓰기전에 반드시 Content-Length 헤더에 본문의 길이를 담아 보낸다.
    청크 인코딩은 보내기 전에 본문의 길이를 알지 못할때 빛을 발휘한다. 전송되는 청크에 그 크기를 담아 보낼 수 있다. 서버는 크기가 0인 청크로 본문이 끝났음을 알린다.
    
    청크는 16진수의 본문 길이와 본문이 CRLF로 구분되어 있다.
    
- 청크 인코딩된 메시지의 트레일러
    
    다음 조건을 하나라도 만족하면 청크 메시지에 트레일러를 사용할 수 있다.
    
    - 클라이언트의 TE 헤더가 트레일러를 받아들일 수 있을 때
    - 트레일러가 응답을 만든 서버에 추가되었으며, 트레일러 콘텐츠를 무시하고 버려도 되는 경우

### 콘텐츠와 전송 인코딩의 조합

콘텐츠 인코딩과 전송 인코딩은 동시에 사용 불가능하다.

콘텐츠 인코딩을 사용해 HTML을 압축하고 전송하는 과정에서 청크 인코딩을 한다. 수신은 반대로

### 전송 인코딩 규칙

- 전송 인코딩 집합은 반드시 chunked를 포함해야 한다.
- 청크 인코딩이 사용된 경우 메시지 본문에 적용된 마지막 전송 인코딩이 존재해야 한다.
- 청크 인코딩은 반드시 메시지 본문에 한 번 이상 적용되어야 한다. (메시지 전송 길이를 알기 위해)

# 7. 시간에 따라 바뀌는 인스턴스

시간에 따라 서버의 객체가 달라질 수 있다. 이를 HTTP 조작이라 하며 객체의 인스턴스에 작용한다.

이중  대표적인 두 가지가 범위 요청과 델타 인코딩이다.

이는 자신의 리소스 사본과 서버의 리소스가 같은지 판단하고 새로 요청할 수 있다.

# 8. 검사기와 신선도

서버에게 받은 리소스를 가지고 있다가, 이 사본이 유효하지 않게되면 새로운 리소스로 교체한다. 이는 신선도, 검사기, 조건에 의해 이루어진다.

### 8.1 신선도

캐시 시간과, 리소스가 유효한지에 대한 정보이다.

Expires, Cache-Control 헤더를 통해 이 정보를 제공한다.

- Expiers 헤더는 만료 시간을 기재한다.
- Cache-Control 헤더는 no-cache등 캐시 지시자를 나타낸다

### 8.2 조건부 요청과 검사기

캐시의 유효기간이 지났어도 서버에서 변경점이 없다면 새로 호출할 필요가 없다.

이를 위해 리소스가 변경된 경우에만 요청을 하는 방법이 있다.

검사기 유형은 두개가 있다.

**Last-Modified**

- GET 메서드와 If-Modified-Since:날짜를 통해 변경된 경우에만 값을 받을 수 있다.
여기서 사용된 조건부 헤더는 참이 아니면 에러코드를 반환한다.
- If-Unmodified_since 마지막으로 수정된 버전에서 변한 것이 있따면 그 사본을 보내라

**ETag**

- If-Match 지난번 ETag 응답 헤더에 들어있던 것과 엔티티 태그가 같다면 그 사본을 보내라.
- If-None-Match 지난번 ETag 응답 헤더에 들어있떤 것과 엔티티 태그가 다르다면 그 사본을 보내라.

약한 검사기중 바이트 크기를 검사하고, 강한 검사기는 암호 체크섬을 검사한다.

ETag은 강한 검사기로 간주된다. 강한 검사기는 엔티티 값이 조금이라도 바뀌어도 재검사를 한다.

# 9. 범위 요청

클라이언트가 서버에게 리소스 요청을 할 때 특정 범위만 요청할 수 있다.

범위 요청은 객체의 특정 인스턴스를 클라이언트와 서버가 같은 버전을 가지고 있을때만 의미가 있다.


![image](https://github.com/Deep-Dive-Study/http-perfect-guide/assets/85796588/29e3b5b2-b5d8-4102-9376-71c06c9b0132)


# 10. 델타 인코딩

웹 페이지의 각기 다른 버전은 그 페이지에 대한 각기 다른 인스턴스이다.

만약 클라이언트가 어떤 페이지의 만료된 사본을 갖고 있다면

사본을 요청하는 것에 대해서 부분 또는 전체를 요청하는 것은 HTTP 프로토콜의 확장이다.

델타 인코딩은 일종의 인스턴스 조작으로 객체의 특정 인스턴스들에 대한 클라이언트와 서버 사이의 정보 교환에 의존하기 때문이다.

- 처음 응답을 받아 캐싱한다.
- 캐시의 사본이 만료되면 서버에 다시 요청한다. + 이때 델타를 받아들이겠다는 의사와 함께 보낸다.
    - Etag의 정보를 If-None-Match 헤더에 담는다.
    - A-IM 헤더에 자신이 델타를 받아들일 수 있다고 전한다.
- 서버는 응답할때 IM 헤더에 인스턴스 조작의 종류를 명시하고, Delta-Base헤더를 명시한다.
- 델타를 받고 캐시된 버전에 적용하여 최신 버전을 생성한다. 이때 ETag를 갱신한다.
    
    

### 10.1 델타 생성기

A-IM 헤더 : 자신이 받아들일 수 있는 인스턴스 조작의 종류를 명시한다.

IM : 사용한 인스턴스 조작의 종류를 명시한다.
