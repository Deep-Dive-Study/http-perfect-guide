# 16장. 국제화
- HTTP 는 여러 언어와 문자로 된 국제 문서들의 처리 및 전송을 지원해야함
  - 문자집합 인코딩 및 언어 태그

## 16.1 국제적인 콘텐츠를 다루기 위해 필요한 HTTP 지원
- HTTP 메시지는 어떤 언어로 된 콘텐츠든 미디어처럼 실어 나를 수 있음
  - 엔티티 본문은 그냥 비트 덩어리 
- 국제 콘텐츠를 지원하기 위해, 서버는 클라이언트에게 문서의 문자와 언어를 알려줘야 하며
- 클라이언트가 올바르게 문서를 이루고 있는 비트들을 문자들로 풀어내고, 올바르게 처리해서 사용자에게 콘텐츠를 제공할 수 있도록 할 필요가 있음

- 서버는 클라이언트에게 문서의 문자와 언어를 HTTP `Content-Type` `charset` 매개변수와 `Content-Language` 헤더를 통해 알려줌
- 클라이언트는 서버에게 어떤 언어를 이해할 수 있고 알파벳의 코딩 알고리즘이 브라우저에 설치되어 있는지 Aceept-Charset, Accept-Language 를 이용하여 알려줄 필요가 있음

  ![CleanShot 2024-01-11 at 21 20 38](https://github.com/Deep-Dive-Study/http-perfect-guide/assets/99165624/4083ff20-3ef2-4812-9840-ca7835b8ccf9)

## 16.2 문자집합과 HTTP

### 16.2.1 Charset 은 글자를 비트로 변환하는 인코딩이다
- HTTP Charset 값은, 어떻게 엔터티 콘텐츠 비트들을 특정 문자 체계의 글자들로 바꾸는지 말해줌
- Charset 태그는 비트들을 글자들로 변환하거나 그 반대의 일을 해주는 알고리즘을 명명함

  ![CleanShot 2024-01-11 at 21 23 06](https://github.com/Deep-Dive-Study/http-perfect-guide/assets/99165624/140476bc-647e-48fd-9c2c-62cc3e6979f5)

  ![CleanShot 2024-01-11 at 21 22 52](https://github.com/Deep-Dive-Study/http-perfect-guide/assets/99165624/eda165d2-953e-4fb8-8d94-a5ccb1556313)

### 16.2.2 문자집합과 인코딩은 어떻게 동작하는가
- 문서를 이루는 비트들은, 특정 코딩된 문자집합의 특정 문자로 식별될 수 있는 문자 코드로 변환됨
- 문자 코드는 코딩된 문자집합의 특정 요소를 선택하기 위해 사용됨
- 각 단계에서 사용되는 알고리즘은 MIME charset 태그를 통해 결정됨

  ![CleanShot 2024-01-11 at 21 26 09](https://github.com/Deep-Dive-Study/http-perfect-guide/assets/99165624/cfef7cf8-c677-454d-85e3-78c6ca2fa330)

- 국제화된 문자 시스템의 핵심 목표는 표현에서 의미를 분리하는 것
- HTTP 는 문자 데이터 및 그와 관련된 언어와 charset 라벨의 전송에만 관심을 가짐

### 16.2.3 잘못된 Charset 은 잘못된 글자들을 낳는다
- 클라이언트가 잘못된 charset 매개변수를 사용한다면, 클라이언트는 이상한 깨진 글자를 보여주게 될 것

  ![CleanShot 2024-01-11 at 21 26 36](https://github.com/Deep-Dive-Study/http-perfect-guide/assets/99165624/af59a8ce-4c28-4cb8-89a8-57ab3c53d43b)

### 16.2.4 표준화된 MIME Charset 값 
- 특정 문자 인코딩과 특정 코딩된 문자집합의 결합을 MIME Charset 이라고 부름
- HTTP 는 표준화된 MIME Charset 태그를 Content-Type 과 Acccept-Charset 헤더에 사용

- MIME 값 종류
 
  ![CleanShot 2024-01-11 at 21 27 34](https://github.com/Deep-Dive-Study/http-perfect-guide/assets/99165624/fd2d2a0c-dfe0-4879-b849-71303ff7906c)


### 16.2.5 Content-Type charset 헤더와 META 태그

![CleanShot 2024-01-11 at 21 28 20](https://github.com/Deep-Dive-Study/http-perfect-guide/assets/99165624/627c8a64-2e2e-4bc8-90ec-4fd94ac26453)

- 웹 서버는 클라이언트에게 MIME Charset 태그를 charset 매개변수와 함께 Content-Type 에 담아 보냄
- 만약 문자집합이 명시적으로 나열되지 않았다면, 수신자는 문서의 콘텐츠로부터 문자집합을 추측하려 시도함
- HTML Content 에서 문자 집합은 문자 집합을 서술하는 `<META HTTP-EQUIV="Content-Type">` 태그에서 찾을 수 있음
- 만약 클라이언트가 문자 인코딩을 추측하지 못했다면, iso-8859-1 인것으로 가정

  ![CleanShot 2024-01-11 at 21 29 12](https://github.com/Deep-Dive-Study/http-perfect-guide/assets/99165624/9873b884-dc0e-4e78-8c08-db9f85b48eb1)

### 16.2.6 Accept-Charset 헤더
  
  ![CleanShot 2024-01-11 at 21 36 41](https://github.com/Deep-Dive-Study/http-perfect-guide/assets/99165624/37eb8ae0-cf12-4228-ad2b-c617fe76794a)

- 대부분의 클라이언트는 모든 종류의 문자 코딩과 매핑 시스템을 지원하지 않음
  - 따라서, HTTP 클라이언트는 서버에게 정확히 어떤 문자 체계를 그들이 지원하는지 Accept-Charset 요청 헤더를 통해 알려줘야함
- Accpt-Charset 헤더의 값은 클라이언트가 지원하는 문자 인코딩의 목록을 제공
- 문자 인코딩 중 어떤 것으로 콘텐츠를 반환할지는 서버의 자유

- Accept-Charset 요청 헤더에 대응하는 Content-Charset 응답 헤더는 존재하지 않음
  - 응답 문자집합은 MIME 과의 호환을 위해 Content-Type 응답 헤더의 charset 매개변수를 통해 서버로부터 돌려받음

## 16.3 다중언어 문자 인코딩에 대한 지침

### 16.3.1 문자집합 용어

- 문자: 글쓰기의 최소 단위, 약식으로 유니코드라고 불리는 국제 문자 세트
- 글리프: 하나의 글자를 표현하기 위한, 획의 패턴이나 다른 것과 구분되는 유일한 시각적 형태 
- 코딩된 문자: 글자를 다룰 수 있도록 글자에 할당된 유일한 숫자 
- 코드 공간: 문자 코드 값으로 사용하려고 계획해 둔 정수의 범위
- 코드 너비: 문자 코드의 비트 개수
- 사용 가능 문자 집합: 글자들에 대한 특정한 작업 집합
- 코딩된 문자집합: 사용 가능 문자집합을 받아서 각 글자에 코드 공간이 코드를 할당해주는 코딩된 문자들의 집합
- 문자 인코딩 구조: 숫자로 된 문자 코드들을 콘텐츠 비트의 연속으로 인코딩하는 알고리즘 

### 16.3.2 Charset 은 형편없는 이름이다
- MIME Charset 태그는 문자집합을 의미하는 것이 아님
  - 데이터 비트를 고유한 문자의 코드로 매핑하는 알고리즘의 이름
- 이것은 문자 인코딩 구조와 코딩된 문자집합의 개념을 합친 것

## 16.4 언어 태그와 HTTP
- 언어 태그는 언어에 이름을 붙이기 위한 짧고 표준화된 문자열
  - 언어 태그는 지역에 따라 변형된 언어나 방언을 표현할 수 있음

### 16.4.1 Content-Language 헤더 
  
  ![CleanShot 2024-01-11 at 21 40 25](https://github.com/Deep-Dive-Study/http-perfect-guide/assets/99165624/e9091d5b-95b9-438a-8c6b-4f98b60c060d)

- Content-Language 엔터티 헤더 필드는 엔터티가 어떤 언어 사용자를 대상으로 하고 있는지 서술함
- Content-Language 헤더는 텍스트 문서만을 위한 것이 아님
  - 오디오 클립, 동영상, 애플리케이션도 특정 언어 사용자를 대상으로 할 수 있음

![CleanShot 2024-01-11 at 21 40 11](https://github.com/Deep-Dive-Study/http-perfect-guide/assets/99165624/3cdf985d-c485-43eb-a6ea-ef24aee09fa8)


### 16.4.2 Accept-Language 헤더
- HTTP 는 우리에게 우리의 언어 제약과 선호도를 웹 서버에 전달할 수 있게 해줌
- 웹 서버가 어떤 자원에 대해 여러 언어로 된 버전을 갖고 있다면, 웹 서버는 우리가 선호하는 언어로 된 콘텐츠를 줄 수 있음

  ![CleanShot 2024-01-11 at 21 40 45](https://github.com/Deep-Dive-Study/http-perfect-guide/assets/99165624/a8da1ec5-46c4-490e-a8ff-969b94ce8ccb)

### 16.4.3 언어 태그의 종류 
- 언어 태그는 PFC 3066 로 문서화된 표준화된 문법을 갖고 있음

  ![CleanShot 2024-01-11 at 21 41 01](https://github.com/Deep-Dive-Study/http-perfect-guide/assets/99165624/56f10dc8-c0ad-4bd0-af5e-c7d5999879be)

### 16.4.4 서브태그
- 언어 태그는 하이픈으로 분리된 하나 이상의 서브태그로 이루어져 있음
- 서브태그는 A-Z 까지의 글자만을 포함

![CleanShot 2024-01-11 at 21 41 14](https://github.com/Deep-Dive-Study/http-perfect-guide/assets/99165624/4009b60d-f69c-49bf-999c-1ef14d8897e4)

- 첫 번째 서브태그는 주 서브태그라 불림
  - 이 값들은 표준화되어 있음
- 두 번째 서브태그는 선택적이고 자신만의 이름 표준을 따름
- 세 번째부터의 서브태그는 등록되어 있지 않음

### 16.4.5 대소문자의 구분 및 표현 
- 모든 태그는 대소문자가 구분되지 않음
  - 태그 'en' 과 'eN' 은 같음
- 그러나 관용적으로 언어를 나타낼 떄는 소문자를 사용하고, 국가를 나타낼 떄는 대문자를 사용함

### 16.4.6 IANA 언어 태그 등록
- 첫 번쨰와 두 번째 언어 서브태그의 값은 여러 가지 표준 문서와 그것들을 관리하는 조직에 의해서 정의됨
  - IANA 는 RFC 3066 의 규칙에 따라 표준 언어 태그의 목록을 관리함

### 16.4.7 첫 번째 서브태그: 이름공간
- 첫 번째 서브태그는 보통 ISO 639 표준 언어 집합에서 선택된 표준화된 언어 토큰
- 그러나 또한 IANA 에서 등록한 이름을 의미하는 글자 'i' 일 수도 있고, 특정 집단의 전용 확장 이름임을 의미하는 'x' 일 수도 있음

  ![CleanShot 2024-01-11 at 21 42 16](https://github.com/Deep-Dive-Study/http-perfect-guide/assets/99165624/0b233a8c-a250-4012-99a8-17e2eac1c604)

### 16.4.8 두 번째 서브태그: 이름공간
- 두 번째 서브태그는 보통 ISO 3166 국가 코드와 지역 표준 집합에서 선택된 표준화 된 국가 토큰
  - IANA 에 등록된 다른 문자열일 수도 있음
  
  ![CleanShot 2024-01-11 at 21 42 48](https://github.com/Deep-Dive-Study/http-perfect-guide/assets/99165624/ac2c9e9d-b67f-4594-bd5e-efdbaa7c8063)


### 16.4.9 나머지 서브태그: 이름공간
- 세 번째와 그 이후의 서브태그에 대해서는, 8자 이하의 알파벳과 숫자가 이루어져야 한다는 것을 제외하면 다른 규칙은 없음

### 16.4.10 선호 언어 설정하기
- 웹 브라우저 프로필에서 선호 언어를 선택할 수 있음

## 16.5 국제화된 URI
- 오늘날 URI 는 국제화를 그다지 지원하지 않음
  - 몇 가지 예외와 함께, 오늘날의 URI 는 US-ASCII의 부분집합으로 구성됨

### 16.5.1 국제적 가독성 vs 의미 있는 문자들
- URI 설계자들은 전 세계의 모두가 URI 를 이메일, 전화, 광고판, 라디오 등을 통해 다른 이들과 공유할 수 있기를 원했음
  - 공유하기 쉽게 설계자들은 제한된 공통 문자집합을 선택했음
  - URI 저자들은 리소스 식별자의 가독성과 공유 가능성의 보장이, 대부분의 의미 있는 문자들로 구성될 수 있도록 하는 것보다 더 중요하다고 여겼음

- 그래서 우리들은 ASCII 문자들의 제한된 집합으로 이루어진 URI 를 갖게됨

### 16.5.2 URI 에서 사용될 수 있는 문자들
- URI 에서 사용할 수 있는 US-ASCII 문자들의 부분집합은 예약된 문자들, 예약되지 않은 문자들, 이스케이프 문자들로 나뉨
- 예약되지 않은 문자들은 그것들을 허용하는 URI 의 어떤 구성요소에서든 일반적으로 사용될 수 있음

  ![CleanShot 2024-01-11 at 21 43 29](https://github.com/Deep-Dive-Study/http-perfect-guide/assets/99165624/fafb93c0-908c-4dd2-8bd8-458a050af0ed)

### 16.5.3 이스케이핑과 역 이스케이핑 
- URI 이스케이프는 예약된 문자나 다른 지원하지 않는 글자들을 안전하게 URI 에 삽입할 수 있는 방법을 제공
  - 이스케이프는 퍼센트 글자 하나와 뒤이은 16진수 글자 둘로 이루어진 세 글자 문자열

- 16진수 두 글자는 US-ASCII 문자의 코드를 나타냄

  ![CleanShot 2024-01-11 at 21 43 43](https://github.com/Deep-Dive-Study/http-perfect-guide/assets/99165624/ddd377f4-cf73-445f-b8f0-8947270b5a63)

- 내부적으로 HTTP 애플리케이션은 URI 를 데이터가 필요할 때만 언이스케이핑해야함
- 애플리케이션은 어떤 URI 도 두 번 언이스케이핑 되지 않도록 해야함

### 16.5.4 국제 문자들을 이스케이핑하기 
- 이스케이프 값들은 US-ASCII 코드의 범위에 있어야 함에 주의해야함
- 웹 서버는 국제 문자를 포함한 파일 이름을 부호화하기 위해 이스케이핑을 오용했을 수도 있음
  - 이는 부정확하며 어떤 애플리케이션에서는 문제를 유발할 수 있음

### 16.5.5 URI 에서의 모달 전환
- 몇몇 URI는 다른 문자집합의 글자를 표현하기 위해 ASCII 문자열을 사용함
- 현재 URI 는 그다지 국제화에 친화적이지 않음
  - URI 이식성의 목표는 언어 유연성의 목표보다 중요했음

## 16.6 기타 고려사항

### 16.6.1 헤더와 명세에 맞지 않는 데이터
- HTTP 헤더는 반드시 US-ASCII 문자집합의 글자들로만 이루어져야 함
- 그러나, 모든 클라이언트와 서버가 이를 올바르게 구현한 것은 아니므로, 때때로 127보다 큰 코드 값을 갖는 잘못된 문자를 받게 될 수도 있음
  - HTTP 메시지를 처리학 위해 문자 구분 라이브러리를 사용하기 전에, 메시지에 잘못된 데이터가 포함되어 있을 경우를 대비해 문서를 주의 깊게 읽어야함

### 16.2.2 날짜 
- HTTP 명세는 올바른 GMT 날짜 형식을 명확히 정의하고 있지만 모든 웹 서버와 클라이언트가 규칙을 따르고 있지 않음에 주의하자
- HTTP 애플리케이션은 명세에 맞지 않는 날짜를 관대하게 받아들이고, 받아들이면서 충돌을 일으키지 말아야함

### 16.6.3 도메인 이름
- 국제화 문자를 포함하는 도메인 이름을 국제화 도메인 이름이라고 하는데, 오늘날 대부분의 웹브라우저가 `퓨니코드`를 이용해 이를 지원함
  - 퓨니코드란? 유니코드 문자열을 호스트 명에서 사용가능한 문자만으로 이루어진 문자열로 변환하는 방법
